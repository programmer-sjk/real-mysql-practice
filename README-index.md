# 8. 인덱스

## 8.1 디스크 읽기 방식

- 컴퓨터의 cpu나 메모리 장치는 매우 빠르게 발전했지만, 반대로 디스크는 제한적으로 발전했다.
- **SSD**처럼 빠른 디스크가 활용되더라도, 여전히 컴퓨터에서 **가장 느린 부분**이라는 사실은 변함이 없고
DB 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건이다.

### 8.1.1 HDD와 SSD

- SSD는 기존 하드 디스크에서 원판을 제거하고 플래시 메모리를 장착하고 있다. 원판을 기계적으로 회전시킬 필요가 없어서
빠르게 데이터를 읽고 쓸 수 있다.
- 컴퓨터 장치의 1초당 처리 횟수
  - 메모리가 SSD보다 1000배 더 많이 처리할 수 있으며 요즘은 DBMS로 사용하는 서버가 대부분 SSD를 사용한다.

```text
cpu: 1,000,000,000
Dram:  100,000,000
SSD:       100,000
HDD:           200
```

- 디스크 헤더를 움직이지 않고 순차적으로 데이터를 읽는 I/O에서는 SSD랑 HDD랑 크게 차이가 없다.
- SSD의 장점은 랜덤 I/O가 HDD보다 훨씬 빠르다는 점이다. DB에서 순차 I/O 작업보다는 랜덤 I/O 작업이 많이 
일어나기 때문에 SSD는 DBMS 스토리지에 최적이라고 볼 수 있다.

### 8.1.2 랜덤 I/O와 순차 I/O

- **랜덤 I/O와 순차 I/O**의 차이를 먼저 보자. 3개의 데이터를 **디스크에 쓴다고 가정**할 때
디스크에 기록해야 할 위치를 찾기 위해 순차 I/O는 디스크 헤더를 1번 움직였고 랜덤 I/O는 3번 움직였다.
- 디스크에 데이터를 쓰고 읽는데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다.
즉, 디스크 헤더의 위치 이동없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의해 결정된다.
- **SSD의 경우** 디스크 원판을 가지고 있진 않지만 여전히 랜덤 I/O가 순차 I/O보다 성능이 떨어진다.
- 쿼리를 튜닝한다는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이고, 쿼리를 처리하면서 꼭 필요한 데이터를 읽도록 쿼리를 개선한다는 의미이다.

## 8.2 인덱스란?

- 인덱스란, 인덱스로 정한 칼럼의 값과 해당 레코드가 저장된 주소를 key-value로 삼아 만들어 둔 것이다.
- 책의 찾아보기와 인덱스의 공통점은 정렬이다. 책의 찾아보기도 내용이 많아지면 ㄱ,ㄴ,ㄷ 순으로 정렬하는데
인덱스도 마찬가지로 주어진 칼럼의 값으로 미리 정렬해서 보관해둔다.
- 인덱스는 저장될 때마다 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만, 이미 정렬되어 있기 때문에
원하는 값을 빠르게 찾아올 수 있다.
- 결론적으로 인덱스는 **저장(insert, update, delete) 성능을 희생하고 데이터의 읽기 속도를 높이는 기능**이다.
- 인덱스는 **프라이머리 키와 세컨더리 키**로 구분할 수 있다.
  - 프라이머리 키는 id 처럼 레코드를 대표하는 식별 값으로 null을 허용하지 않으며 중복을 허용하지 않는다.
  - 프라이머리 키를 제외한 모든 인덱스는 세컨더리 인덱스로 분류한다.
- 인덱스를 저장방식(알고리즘)으로 구분할 경우 대표적으로 **B-Tree 인덱스와 Hash 인덱스**로 구분된다.
  - B-Tree 인덱스는 가장 일반적으로 사용하고 성숙해진 상태다. 
  - Hash 인덱스는 컬럼의 값으로 해시값을 계산하는 방식으로 매우 빠른 검색을 지원하며 주로 메모리 기반의 DB에서 사용된다.

## 8.3 B-Tree 인덱스

### 8.3.1 B-Tree 인덱스

- B-Tree 인덱스를 이해하려면 B-Tree의 기본적인 구조를 알아야 한다.
- B-Tree는 최상위에 하나의 루트 노드가 존재하고, 가장 하위에 리프 노드가 있으며 중간에 있는 노드를 브랜치 노드라고 한다.
- 인덱스의 **리프 노드**는 항상 실제 **데이터 레코드의 주소값**을 가지고 있다.
- 인덱스의 키 값은 정렬되어 있지만 디스크의 데이터는 임의의 순서로 저장된다.
- 인덱스는 테이블의 키 칼럼만 가지고 있고 나머지 데이터는 레코드에서 찾아야 한다. 이를 위해 인덱스의 리프 노드는 데이터
파일에 저장된 레코드의 주소를 가진다. 아래 예시는 B-Tree 리프노드와 MyISAM 저장 방식이다.
  ![리프노드와 데이터 레코드](images/leaf_node.png)
- MyISAM은 인덱스의 리프노드에 물리적인 주소를 가지는 반면, InnoDB 테이블은 프라이머리 키를 가지고 있어 논리적인 주소를 가진다고 볼 수 있다. 따라서 InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때는 데이터를 바로 찾아가지 못하고
인덱스에 저장돼 있는 프라이머리 키에 해당하는 프라이머리 키 인덱스의 리프 노드에 저장된 레코드를 읽는다.
- 즉, InnoDB에서 물리적인 주소를 가지는 건 프라이머리 키 인덱스의 리프 노드이며, InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한 번 검색해야 한다.
- 성능이 떨어질 것 처럼 보이지만 사실은 각각의 장단점이 있다.

### 8.3.2 B-Tree 인덱스 키 추가 & 삭제

- 
