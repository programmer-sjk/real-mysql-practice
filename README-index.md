# 8. 인덱스

## 8.1 디스크 읽기 방식

- 컴퓨터의 cpu나 메모리 장치는 매우 빠르게 발전했지만, 반대로 디스크는 제한적으로 발전했다.
- **SSD**처럼 빠른 디스크가 활용되더라도, 여전히 컴퓨터에서 **가장 느린 부분**이라는 사실은 변함이 없고
DB 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건이다.

### 8.1.1 HDD와 SSD

- SSD는 기존 하드 디스크에서 원판을 제거하고 플래시 메모리를 장착하고 있다. 원판을 기계적으로 회전시킬 필요가 없어서
빠르게 데이터를 읽고 쓸 수 있다.
- 컴퓨터 장치의 1초당 처리 횟수
  - 메모리가 SSD보다 1000배 더 많이 처리할 수 있으며 요즘은 DBMS로 사용하는 서버가 대부분 SSD를 사용한다.

```text
cpu: 1,000,000,000
Dram:  100,000,000
SSD:       100,000
HDD:           200
```

- 디스크 헤더를 움직이지 않고 순차적으로 데이터를 읽는 I/O에서는 SSD랑 HDD랑 크게 차이가 없다.
- SSD의 장점은 랜덤 I/O가 HDD보다 훨씬 빠르다는 점이다. DB에서 순차 I/O 작업보다는 랜덤 I/O 작업이 많이 
일어나기 때문에 SSD는 DBMS 스토리지에 최적이라고 볼 수 있다.

### 8.1.2 랜덤 I/O와 순차 I/O

- **랜덤 I/O와 순차 I/O**의 차이를 먼저 보자. 3개의 데이터를 **디스크에 쓴다고 가정**할 때
디스크에 기록해야 할 위치를 찾기 위해 순차 I/O는 디스크 헤더를 1번 움직였고 랜덤 I/O는 3번 움직였다.
- 디스크에 데이터를 쓰고 읽는데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다.
즉, 디스크 헤더의 위치 이동없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의해 결정된다.
- **SSD의 경우** 디스크 원판을 가지고 있진 않지만 여전히 랜덤 I/O가 순차 I/O보다 성능이 떨어진다.
- 쿼리를 튜닝한다는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이고, 쿼리를 처리하면서 꼭 필요한 데이터를 읽도록 쿼리를 개선한다는 의미이다.

## 8.2 인덱스란?

- 인덱스란, 인덱스로 정한 칼럼의 값과 해당 레코드가 저장된 주소를 key-value로 삼아 만들어 둔 것이다.
- 책의 찾아보기와 인덱스의 공통점은 정렬이다. 책의 찾아보기도 내용이 많아지면 ㄱ,ㄴ,ㄷ 순으로 정렬하는데
인덱스도 마찬가지로 주어진 칼럼의 값으로 미리 정렬해서 보관해둔다.
- 인덱스는 저장될 때마다 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만, 이미 정렬되어 있기 때문에
원하는 값을 빠르게 찾아올 수 있다.
- 결론적으로 인덱스는 **저장(insert, update, delete) 성능을 희생하고 데이터의 읽기 속도를 높이는 기능**이다.
- 인덱스는 **프라이머리 키와 세컨더리 키**로 구분할 수 있다.
  - 프라이머리 키는 id 처럼 레코드를 대표하는 식별 값으로 null을 허용하지 않으며 중복을 허용하지 않는다.
  - 프라이머리 키를 제외한 모든 인덱스는 세컨더리 인덱스로 분류한다.
- 인덱스를 저장방식(알고리즘)으로 구분할 경우 대표적으로 **B-Tree 인덱스와 Hash 인덱스**로 구분된다.
  - B-Tree 인덱스는 가장 일반적으로 사용하고 성숙해진 상태다. 
  - Hash 인덱스는 컬럼의 값으로 해시값을 계산하는 방식으로 매우 빠른 검색을 지원하며 주로 메모리 기반의 DB에서 사용된다.

## 8.3 B-Tree 인덱스

### 8.3.1 B-Tree 인덱스

- B-Tree 인덱스를 이해하려면 B-Tree의 기본적인 구조를 알아야 한다.
- B-Tree는 최상위에 하나의 루트 노드가 존재하고, 가장 하위에 리프 노드가 있으며 중간에 있는 노드를 브랜치 노드라고 한다.
- 인덱스의 **리프 노드**는 항상 실제 **데이터 레코드의 주소값**을 가지고 있다.
- 인덱스의 키 값은 정렬되어 있지만 디스크의 데이터는 임의의 순서로 저장된다.
- 인덱스는 테이블의 키 칼럼만 가지고 있고 나머지 데이터는 레코드에서 찾아야 한다. 이를 위해 인덱스의 리프 노드는 데이터
파일에 저장된 레코드의 주소를 가진다. 아래 예시는 B-Tree 리프노드와 MyISAM 저장 방식이다.
  ![리프노드와 데이터 레코드](images/leaf_node.png)
- MyISAM은 인덱스의 리프노드에 물리적인 주소를 가지는 반면, InnoDB 테이블은 프라이머리 키를 가지고 있어 논리적인 주소를 가진다고 볼 수 있다. 따라서 InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때는 데이터를 바로 찾아가지 못하고
인덱스에 저장돼 있는 프라이머리 키에 해당하는 프라이머리 키 인덱스의 리프 노드에 저장된 레코드를 읽는다.
- 즉, InnoDB에서 물리적인 주소를 가지는 건 프라이머리 키 인덱스의 리프 노드이며, InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한 번 검색해야 한다.
- 성능이 떨어질 것 처럼 보이지만 사실은 각각의 장단점이 있다.

### 8.3.2 B-Tree 인덱스 키 추가 & 삭제

- 새로운 인덱스 키 값이 B-Tree에 저장될 때, 저장할 위치를 찾고 레코드의 키 값과 레코드의 주소 정보를 
B-Tree 리프노드에 저장한다. 만약 리프 노드가 꽉 차서 저장할 수 없을 때 분리해야 하는데 이는 상위 브랜치 노드까지
처리해야 하는 작업으로, 상대적으로 새로운 키를 추가하는 작업은 비용이 많이 드는 것으로 알려졌다.
- **인덱스 키 삭제**는, 키 값이 저장된 리프 노드를 찾아 삭제 마크만 하기 때문에 간단하다.
- **인덱스 키 수정**은, 기존 인덱스 키 값을 삭제 후 새로운 인덱스 키 값을 추가하는 작업으로 처리된다.
- **인덱스 키 검색**은 트리 탐색을 통해 루트 노드 -> 브랜치 노드 -> 리프 노드까지 이동하는데, 인덱스의 키 값이 변형된 후
비교되어 질 경우 인덱스를 탈 수 없다.

### 8.3.3 B-Tree 인덱스에 영향을 미치는 요소

#### 8.3.3.1 인덱스 키 값의 크기

- InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지 or 블록이라고 하며 디스크의 읽기/쓰기 작업의
최소 작업 단위가 된다.
- 이진트리는 각 노드가 자식 노드를 2개만 가지는데 DBMS의 B-Tree가 이진 트리라면 인덱스 검색이 비효율적이다.
**B-Tree는 Balanced Tree**로 DBMS의 B-Tree 자식 노드의 개수는 가변적이다.
- MySQL의 경우 페이지의 기본 크기가 16KB라면, 인덱스 키가 16KB이고 자식 노드의 크기가 12 바이트일 때 하나의 인덱스 페이지(16KB)에 몇 개의 키를 저장할 수 있을까? 
![인덱스 페이지 구성](images/index_페이지_구성.png) 
  - 계산해보면 16KB = 16 * 1024 / (16+12) = 585개 저장할 수 있다.
  - 만약 키가 32바이트로 늘어나면 16 * 1024 / (32+12) = 372개를 저장할 수 있다.
  - 만약 select 쿼리가 500개를 읽어야 한다면 전자는 인덱스 페이지 한 번으로 해결되지만 후자는 최소한 2번 이상 디스크에서 읽어야 한다.
  - 결국 인덱스의 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고 그만큼 느려진다는 의미이다.

#### 8.3.3.2 B-Tree 깊이

- 인덱스의 키 값과 연결되는데, 키 값의 크기가 커지면 하나의 인덱스 페이지에 담을 수 있는 개수가 적어지고 그 때문에 B-Tree의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하다.

#### 8.3.3.3 카디널리티

- 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.
- 만약 데이터가 1만건이 저장되어 있고 
  - 유니크한 값의 개수가 10개라고 가정하자.
    - 인덱스로 하나의 키 값을 검색했을 때 평균적으로 1000개의 데이터를 읽었기 때문에 1건을 위해 999건을 불필요하게 읽는다.
  - 유니크한 값의 개수가 1000개라고 가정하자.
    - 인덱스로 하나의 키 값을 검색했을 때 평균적으로 10개의 데이터를 읽었기 때문에 1건을 읽고 9건만 불필요하게 읽는다.

#### 8.3.3.4 읽어야 하는 데이터 건수

- 데이터가 100만 건이 저장되어 있는데 이 중, 50만 건을 읽어야 한다고 가정해보자.
  - 전체 데이터를 읽어서 필요없는 50만 건을 버리는게 좋을지, 인덱스를 통해 50만건만 읽어오는게 좋을지 판단해야 한다.
  - 인덱스의 손익 분기점은, 인덱스로 1건을 읽는게 직접 레코드 1건을 읽는 것보다 4~5배 비용이 든다.
  - 즉 인덱스를 통해 읽어야 할 레코드 건수가 전체 테이블 레코드에 20~25%를 넘어서면 풀스캔 후 필터링 하는 방식이 효율적이다.
