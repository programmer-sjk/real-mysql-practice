# 9. 옵티마이저와 인덱스

- 옵티마이저: 쿼리를 최적으로 실행하기 위해, 실행 계획을 수립하는 작업을 담당한다.

## 9.1 개요

### 9.1.1 쿼리 실행절차

- MySQL 서버에서 쿼리가 실행되는 절차는 크게 세 단계로 나뉜다.
  - 쿼리를 MySQL 서버가 이해할 수 있도록 파싱한다.
  - 파싱된 정보로 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다. (옵티마이저)
    - 불필요한 조건 제거 & 복잡한 연산 단순화
    - 테이블 조인이 있는 경우 어떤 순서로 읽을지 결정
    - 조건절과 인덱스 정보를 이용해 어떤 인덱스를 사용할지 결정
    - 읽어온 레코드들을 임시 테이블에 넣고 다시 한번 가공할지 결정
  - 수립된 계획으로 스토리지 엔진으로부터 데이터를 가져온다.

### 9.1.2 옵티마이저 종류

- 현재의 DBMS가 선택하는 비용기반 최적화(CBO), 과거의 규칙기반 최적화(RBO)로 나뉜다.
  - 규칙기반 최적화는 테이블의 레코드 건수나 카디널리티 등을 고려하지 않고 옵티마이저에 내장된
    우선 순위에 따라 실행 계획을 수립, 현재는 사용되지 않는다.
  - 비용기반 최적화는 쿼리를 처리하기 위한 여러가지 방법을 만들고, 각 작업의 부하와 통계 정보를 이용해
    여러 방법의 비용을 산출한다. 그 후 비용이 최소로 소요되는 방식을 택한다.

## 9.2 기본 데이터 처리

- 모든 RDBMS는 데이터를 정렬 & 그루핑 하는 가공 기능을 가지고 있지만, 그 과정은 다양하다.

### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

- 풀 테이블 스캔은 인덱스 없이 데이터를 처음부터 끝까지 읽는 방식으로, MySQL 옵티마이저는
  아래의 조건이 일치할 때 주로 풀 테이블 스캔한다.
  - 테이블 레코드 건수가 너무 작아서, 풀 테이블 스캔하는게 빠를 경우 (페이지 1개로 구성된 경우)
  - WHERE / ON 절에서 인덱스를 이용할 수 있는 조건이 없는 경우
  - 인덱스를 타더라도 조건 일치 레코드 건수가 너무 많은 경우
- 테이블을 처음부터 끝까지 읽는 작업은 많은 I/O를 소모하기에, 각 DBMS는 페이지 단위로 읽어오는 기능을 내장한다.
  - MySQL은 풀 테이블 스캔시, 몇 개씩 페이지를 읽어올지 설정하는 시스템 변수가 X (사람들이 디스크에서 페이지를 하나씩 읽는다고 생각함)
    - MyISAM 에선 맞지만 InnoDB는 틀리다.
    - InnoDB는 한 테이블의 연속된 페이지가 읽히면, 백그라운드 스레드가 미리 데이터를 읽어 InnoDB 버퍼 풀에 적재한다. (리드 어헤드)
    - 즉, 풀 테이블 스캔이 실행되면 처음 몇 개의 페이지는 포그라운드 스레드가 실행하지만, 특정 시점부터 읽기 작업을 백그라운드 스레드가 담당한다.
    - 이 방법을 통해 포그라운드 스레드는 버퍼 풀에 준비된 데이터를 가져가면 되기에 쿼리가 빠르게 처리된다.
- MySQL 서버는 `innodb_read_ahead_threshold` 시스템 변수를 이용해 리드 어헤드 임계값을 설정할 수 있다.
  - 디폴트 설정으로 충분하지만 데이터 웨어하우스 용으로 MySQL을 사용한다면 임계값을 낮춰 빨리 리드 어헤드가 시작되도록 유도하자.
- 히드 어헤드는 풀 인덱스 스캔에서도 사용된다. 풀인덱스 스캔은 인덱스를 처음부터 끝까지 스캔하는 것을 의미한다.
  - select count(*) from employees;
    - 이 쿼리는 조건 없이 레코드 건수를 조회하는데 용량이 적은 인덱스를 선택해 풀 인덱스 스캔이 발생할 확률이 높다.
    - 일반적으로 인덱스 테이블은 2-3개 컬럼으로 구성되기에 테이블 자체보다는 용량이 적어 훨씬 빠른 처리가 가능하다.
  - select * from employees;
    - 이 쿼리는 컬럼이 필요하므로 풀 테이블 스캔이 발생한다. <!-- 인데스 컬럼만 조회한다면? -->

### 9.2.2 병렬 처리

- 병렬 처리는 하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리한다.
  - `innodb_parallel_read_threas` 시스템 변수로 몇 개의 스레드를 이용할지 결정할 수 있다.
- MySQL 8.0 버전에서는 아무런 where 조건 없이 단순히 테이블 전체 쿼리를 가져오는 쿼리만 병렬도 처리된다.
  - select count(*) from users; <!-- 성능 결과 첨부 -->

### 9.2.3 Order By 처리

- 정렬을 처리하기 위해 인덱스를 이용하는 방법과 FileSort 라는 별도의 처리를 이용할 수 있다.
  - 인덱스를 이용한다면?
    - 인덱스가 정렬돼어 있어서 순서대로 읽기만 하니까 매우 빠르다.
    - 인덱스 때문에 디스크 공간 & InnoDB 버퍼풀을 위한 메모리가 많이 필요하다.
  - FileSor를 이용한다면?
    - 인덱스의 단점이 장점으로 적용, 레코드가 적다면 메모리에서 처리하므로 충분히 빠르다.
    - 쿼리 실행시에 정렬이 처리되므로, 레코드 건수가 많을수록 느리다.
- 현실적으로 모든 정렬을 인덱스를 이용하도록 튜닝하는건 불가능
  - 정렬 기준이 너무 많아, 모두 인덱스를 생성하는게 불가능
  - Group By, distinct 처리의 결과를 정렬해야 하는 경우
  - UNION 같은 임시 테이블의 결과를 정렬해야 하는 경우
  - 랜덤하게 결과 레코드를 가져오는 경우
- MySQL 서버에서 별도의 정렬 처리를 수행했는지는, 실행계획의 Extra 칼럼에 Using filesort로 판단할 수 있다.

#### 9.2.3.1 소트 버퍼 (Sort Buffer)

- MySQL은 정렬을 위해 별도의 메모리 공간을 할당받는데, 이 메모리 공간을 소트 버퍼라고 한다.
  - 이 버퍼는 정렬이 필요한 경우에만 할당된다.
  - 버퍼의 크기는 정렬해야 하는 레코드 크기에 따라 가변적으로 변하지만, 최대 사용가능한 공간은 `sort_buffer_size`로 설정한다.
  - 소프 버퍼를 위한 메모리 공간은 쿼리 실행이 완료되면 즉시 해제된다.
- 만약 정렬해야 할 레코드 건수가 할당된 공간보다 크다면 어떻게 될까?
  - 레코드를 여러 조각으로 나눈 뒤, 한 레코드에 대해 소트 버퍼에서 정렬을 수행하고, 그 결과를 디스크에 임시로 저장한다. 그리고 다음 레코드를 가져와 반복한다.
  - 위처럼 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬해야 하는데 이를 멀티 머지라고 부른다.
    - 수행된 멀티 머지 횟수는 Sort_merge_passes 라는 상태변수로 확인할 수 있다.
  - 이 작업들은 모두 디스크 I/O를 유발하며 레코드 건수가 많을수록 반복 횟수가 많아진다.
- 소트 버퍼를 크게 설정하면 메모리에서만 처리되므로 더 빨라질 것 같지만 큰 차이를 보이진 않았다.
  - 256KB ~ 8MB 사이에서 최적의 성능을 보였으며, 그 외에 구간에서는 성능 효과가 없었다.
- 저자의 경험을 기반으로 소트 버퍼 크기는 56KB ~ 1MB 미만이 좋아보인다고 함
  - 소트 버퍼는 공유할 수 있는 메모리가 아니라서, 소트 버퍼크기가 너무 크다면 트래픽이 많을떄 OOM 현상에 의해 강제종료 될 수 있다.

#### 9.2.3.2 정렬 알고리즘

-
